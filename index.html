<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Link Encrypter — Static AES-GCM (Web Crypto)</title>
  <style>
    :root {
      --bg: #0b1220;
      --fg: #e8eefc;
      --dim:#9bb0d6;
      --acc:#7fa2ff;
      --bad:#ff6b6b;
      --ok:#32d296;
      --box:#121a2e;
      --mut:#1a2440;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--fg); background: radial-gradient(1200px 600px at 15% -10%, #1a2b55 0%, transparent 40%), var(--bg);
      display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(900px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid #1f2a48; border-radius: 18px; box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      padding: 22px 22px 8px;
    }
    h1 { margin: 0 0 8px; font-size: 20px; letter-spacing: 0.3px; }
    p { margin: 6px 0 12px; color: var(--dim); }
    .row { display: grid; grid-template-columns: 1fr; gap: 10px; margin: 10px 0; }
    label { font-size: 13px; color: var(--dim); }
    input[type="text"], input[type="password"], input[type="number"], textarea {
      width: 100%; padding: 11px 12px; border-radius: 10px; border: 1px solid #233056; background: var(--box); color: var(--fg);
      outline: none;
    }
    textarea { min-height: 120px; resize: vertical; }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      padding: 10px 14px; border-radius: 10px; border: 1px solid #233056; background: linear-gradient(180deg, #223463, #1a2a53);
      color: var(--fg); cursor: pointer;
      transition: transform .05s ease, box-shadow .2s ease;
    }
    button:hover { box-shadow: 0 6px 20px rgba(0,0,0,0.25); transform: translateY(-1px); }
    .muted { color: var(--dim); font-size: 12px; }
    .warn { color: var(--bad); font-weight: 600; }
    .good { color: var(--ok); font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height: 1px; background: #1f2a48; margin: 14px 0; }
    details { background: var(--mut); border: 1px solid #24325b; border-radius: 12px; padding: 10px 12px; }
    summary { cursor: pointer; }
    .outbox {
      background: #10172b; border: 1px dashed #2a3b6c; border-radius: 12px; padding: 10px;
      word-break: break-all;
    }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Link Encrypter — Static AES‑GCM (Web Crypto)</h1>
    <p class="muted">링크를 암호화합니다. 복호화하려면 암호 문구가 필요합니다. 모든 암호화 작업은 클라이언트 측에서 수행되며, 어느 누구에게도 전송되지 않습니다.</p>

    <div id="encUI" class="">
      <div class="row">
        <label for="inLink">암호화할 링크 (http를 포함한 전체링크여야함)</label>
        <input id="inLink" type="text" placeholder="https://example.com/some/secret?foo=bar" />
      </div>
      <div class="row">
        <label for="inPass">암호 문구(무작위 영단어 7~8개를 권장)</label>
        <input id="inPass" type="password" placeholder="correct horse battery staple ..." autocomplete="new-password" />
      </div>
      <details>
        <summary>고급설정 (PBKDF2 반복횟수)</summary>
        <div class="row">
          <label for="inIter">PBKDF2 반복횟수 (높을수록 강력하지만 느려짐). 기본값 300,000</label>
          <input id="inIter" type="number" min="100000" step="10000" value="300000" />
        </div>
      </details>
      <div class="btns">
        <button id="btnEncrypt">Encrypt & Build Link</button>
        <button id="btnClear">Clear</button>
      </div>
      <div id="encResult" class="hidden">
        <div class="hr"></div>
        <p class="muted">Share this URL. Recipient must enter the same passphrase:</p>
        <div id="outURL" class="outbox mono"></div>
        <div class="btns" style="margin-top:8px">
          <button id="btnCopy">Copy</button>
          <button id="btnOpen">Open in new tab</button>
        </div>
      </div>
      <div class="hr"></div>
      <p class="muted">암호화 알고리즘 : PBKDF2‑SHA‑512 → HKDF‑SHA‑512 → AES‑256‑GCM 추가보안기술 IV & 솔트 무작위화. AAD 헤더 바인딩 AAD</p>
    </div>

    <div id="decUI" class="hidden">
      <div class="row">
        <label>URL에서 암호화된 페이로드가 감지되었습니다. 암호 해독 및 리디렉션을 위해 암호 문구를 입력하세요.</label>
        <input id="decPass" type="password" placeholder="passphrase…" autocomplete="current-password" />
      </div>
      <div class="btns">
        <button id="btnDecrypt">복호화 & 이동</button>
        <button id="btnShow">복호화 시도 (이동없음)</button>
        <button id="btnCancel">취소</button>
      </div>
      <div id="decStatus" class="muted" style="margin-top:8px;"></div>
      <div id="decPreview" class="outbox mono hidden" style="margin-top:8px;"></div>
    </div>
  </div>

<script>
// ======== Helpers: encoding/decoding ========
const te = new TextEncoder();
const td = new TextDecoder();

function toBase64Url(ab) {
  const b64 = btoa(String.fromCharCode(...new Uint8Array(ab)));
  return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
}
function fromBase64Url(b64url) {
  let b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
  const pad = b64.length % 4;
  if (pad) b64 += '='.repeat(4 - pad);
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return bytes.buffer;
}
function hex(ab) {
  return [...new Uint8Array(ab)].map(b=>b.toString(16).padStart(2,'0')).join('');
}
function concatBuffers(...arrs) {
  const total = arrs.reduce((s,a)=> s + a.byteLength, 0);
  const out = new Uint8Array(total);
  let off = 0;
  for (const a of arrs) {
    out.set(new Uint8Array(a), off);
    off += a.byteLength;
  }
  return out.buffer;
}

// ======== Web Crypto utilities ========
async function pbkdf2Bits(passBytes, salt, iterations, lengthBits=256) {
  const key = await crypto.subtle.importKey('raw', passBytes, {name:'PBKDF2'}, false, ['deriveBits']);
  const bits = await crypto.subtle.deriveBits({name:'PBKDF2', hash:'SHA-512', salt, iterations}, key, lengthBits);
  return bits;
}
async function hkdfAesKey(ikmRaw, infoStr) {
  const ikm = await crypto.subtle.importKey('raw', ikmRaw, {name:'HKDF'}, false, ['deriveKey']);
  const aesKey = await crypto.subtle.deriveKey(
    {name:'HKDF', hash:'SHA-512', salt: new Uint8Array([]), info: te.encode(infoStr)},
    ikm,
    {name:'AES-GCM', length: 256},
    false,
    ['encrypt','decrypt']
  );
  return aesKey;
}
function randBytes(n) {
  const a = new Uint8Array(n);
  crypto.getRandomValues(a);
  return a;
}

// ======== Payload packing (JSON → base64url) ========
function buildHeader(obj) {
  // Deterministic header string for AAD
  const hdr = {
    v: obj.v, alg: obj.alg, iter: obj.iter, salt: obj.salt, iv: obj.iv
  };
  return JSON.stringify(hdr);
}
function packPayload(obj) {
  // Full payload (header + ct) -> JSON -> base64url
  const s = JSON.stringify(obj);
  return toBase64Url(te.encode(s).buffer);
}
function unpackPayload(b64url) {
  try {
    const s = td.decode(fromBase64Url(b64url));
    return JSON.parse(s);
  } catch (e) {
    return null;
  }
}

// ======== Encrypt flow ========
async function encryptLink(urlStr, passphrase, iterations) {
  if (!/^https?:\/\//i.test(urlStr)) {
    throw new Error('Link must start with http:// or https://');
  }
  if (!passphrase || passphrase.length < 8) {
    throw new Error('Passphrase too short (min 8 chars, diceware recommended).');
  }
  const salt = randBytes(16);
  const iv = randBytes(12);
  const passBytes = te.encode(passphrase);

  // KDF → HKDF → AES-GCM key
  const ikm = await pbkdf2Bits(passBytes, salt, iterations, 256);
  const key = await hkdfAesKey(ikm, 'enc-link-v1');

  // Header (AAD)
  const payload = {
    v: 1,
    alg: 'PBKDF2-SHA512+HKDF-SHA512+AES-256-GCM',
    iter: iterations,
    salt: toBase64Url(salt.buffer),
    iv: toBase64Url(iv.buffer),
    ct: null
  };
  const aad = te.encode(buildHeader(payload));

  const ciphertext = await crypto.subtle.encrypt({name:'AES-GCM', iv, additionalData: aad, tagLength:128}, key, te.encode(urlStr));
  payload.ct = toBase64Url(ciphertext);

  return packPayload(payload);
}

// ======== Decrypt flow ========
async function decryptLink(payloadB64, passphrase) {
  const obj = unpackPayload(payloadB64);
  if (!obj) throw new Error('Invalid payload format');

  if (!(obj.v === 1 && obj.alg && obj.iter && obj.salt && obj.iv && obj.ct)) {
    throw new Error('Malformed payload fields');
  }
  const salt = fromBase64Url(obj.salt);
  const iv = fromBase64Url(obj.iv);
  const ct = fromBase64Url(obj.ct);

  const passBytes = te.encode(passphrase);
  const ikm = await pbkdf2Bits(passBytes, salt, obj.iter, 256);
  const key = await hkdfAesKey(ikm, 'enc-link-v1');

  const aad = te.encode(buildHeader(obj));
  try {
    const plainBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv, additionalData: aad, tagLength:128}, key, ct);
    const urlStr = td.decode(plainBuf);
    return urlStr;
  } catch (e) {
    throw new Error('Decryption failed (wrong passphrase or tampered data)');
  }
}

// ======== UI glue ========
const $ = (q) => document.querySelector(q);
const encUI = $('#encUI');
const decUI = $('#decUI');

function currentBaseURL() {
  const u = new URL(window.location.href);
  // Build base without query/hash
  return `${u.origin}${u.pathname}`;
}

async function onEncrypt() {
  const link = $('#inLink').value.trim();
  const pass = $('#inPass').value;
  const iters = parseInt($('#inIter').value || '300000', 10);
  const btn = $('#btnEncrypt');
  btn.disabled = true; btn.textContent = 'Encrypting…';
  try {
    const payload = await encryptLink(link, pass, iters);
    const out = `${currentBaseURL()}?link=${encodeURIComponent(payload)}`;
    $('#outURL').textContent = out;
    $('#encResult').classList.remove('hidden');
  } catch (e) {
    alert(e.message || String(e));
  } finally {
    btn.disabled = false; btn.textContent = 'Encrypt & Build Link';
  }
}

async function onDecrypt({redirect}) {
  const pass = $('#decPass').value;
  const status = $('#decStatus'); const preview = $('#decPreview');
  status.textContent = 'Decrypting…'; preview.classList.add('hidden'); preview.textContent='';
  const u = new URL(window.location.href); const payload = u.searchParams.get('link');
  if (!payload) { status.textContent = 'No encrypted payload found.'; return; }
  try {
    const urlStr = await decryptLink(payload, pass);
    status.textContent = '';
    // Safety: only auto-redirect http/https
    if (/^https?:\/\//i.test(urlStr)) {
      if (redirect) {
        window.location.replace(urlStr);
      } else {
        preview.textContent = urlStr; preview.classList.remove('hidden');
      }
    } else {
      status.innerHTML = '<span class="warn">Decrypted text is not an http(s) URL. Showing below for manual copy.</span>';
      preview.textContent = urlStr; preview.classList.remove('hidden');
    }
  } catch (e) {
    status.innerHTML = '<span class="warn">Failed to decrypt. Check passphrase.</span>';
  }
}

function onCopy() {
  const t = $('#outURL').textContent;
  navigator.clipboard.writeText(t).then(()=>{
    $('#outURL').insertAdjacentHTML('afterend','<div class="good" id="copied" style="margin-top:6px">Copied</div>');
    setTimeout(()=>{ const n=$('#copied'); if(n) n.remove(); }, 1000);
  });
}

function initMode() {
  const u = new URL(window.location.href);
  if (u.searchParams.get('link')) {
    encUI.classList.add('hidden');
    decUI.classList.remove('hidden');
    $('#decPass').focus();
  } else {
    encUI.classList.remove('hidden');
    decUI.classList.add('hidden');
    $('#inLink').focus();
  }
}

function bindUI() {
  $('#btnEncrypt').addEventListener('click', onEncrypt);
  $('#btnClear').addEventListener('click', ()=>{
    $('#inLink').value=''; $('#inPass').value=''; $('#encResult').classList.add('hidden'); $('#outURL').textContent='';
  });
  $('#btnCopy').addEventListener('click', onCopy);
  $('#btnOpen').addEventListener('click', ()=>{
    const link = $('#outURL').textContent.trim();
    if (link) window.open(link, '_blank', 'noopener');
  });
  $('#btnDecrypt').addEventListener('click', ()=>onDecrypt({redirect:true}));
  $('#btnShow').addEventListener('click',   ()=>onDecrypt({redirect:false}));
  $('#btnCancel').addEventListener('click', ()=>{ window.location.href = currentBaseURL(); });
}

window.addEventListener('DOMContentLoaded', ()=>{
  if (!('crypto' in window) || !crypto.subtle) {
    alert('This page needs Web Crypto API (secure context: https or localhost).');
  }
  initMode();
  bindUI();
});
</script>
</body>
</html>
